#+startup: content

* Gitconfig
:PROPERTIES:
:header-args: :tangle ~/.config/git/config
:END:

** Include
For [user], [github]

#+begin_src gitconfig :prologue "[include]"
path = ~/.config/git/local
; path = delta_config
#+end_src

** User
#+begin_src gitconfig :prologue "[user]"
;gpgSign = true   # Preferred method for sign-off (less verbose than `git config commit.gpgsign`)
;signinkey=
useConfigOnly=true
#+end_src

** Core
#+begin_src gitconfig :prologue "[core]"
# use $EDITOR?
editor = nvim
compression=9
autocrlf = input
; pager = delta --dark
pager = delta
; hooksPath = ~/.config/git/hooks
; already the default
excludesfile= ~/.config/git/ignore

; fsmonitor=true
; untrackedCache=true

#+end_src

** Init
#+begin_src gitconfig :prologue "[init]"
defaultBranch = main
; init.templatedir
#+end_src

** Alias
I'll use hg aliases whenever possible

#+begin_src gitconfig :prologue "[alias]"
st = status

a = add

ci = commit
br = branch

d = diff
dt = difftool

g = grep

lol = log --oneline
l = log --pretty=format:"%C(yellow)%h\\ %ad%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --date=short

c = clone
review = "!git fetch origin && git difftool -d origin/HEAD...HEAD"

conflicts = diff --check --relative
jump = !sh \"$(locate /usr/share/ -A /git-jump/git-jump)\"

dirdiff = difftool --ignore-submodules --dir-diff --no-symlinks --tool=vimdirdiff
# list branches sorted by last modified
b = "!git for-each-ref --sort='-authordate' --format='%(authordate)%09%(objectname:short)%09%(refname)' refs/heads | sed -e 's-refs/heads/--'"
smartlog = log --graph --pretty=format:'commit: %C(bold red)%h%Creset %C(red)<%H>%Creset %C(bold magenta)%d %Creset%ndate: %C(bold yellow)%cd %Creset%C(yellow)%cr%Creset%nauthor: %C(bold blue)%an%Creset %C(blue)<%ae>%Creset%n%C(cyan)%s%n%Creset'
sl = !git smartlog
me = !git smartlog --author=\"$(git config user.name)\"

# Save a repo as a tarball
export = archive -o latest.tar.gz -9 --prefix=latest/

# Which files are receiving the most "love"
churn = !git log --all -M -C --name-only --format='format:' "$@" | sort | grep -v '^$' | uniq -c | sort | awk 'BEGIN {print "count,file"} {print $1 "," $2}'

# Thin out older metadata within the repository, reduceses filesystem footprint
trim = !git reflog expire --expire=now --all && git gc --prune=now

# what would be merged
in = log HEAD..@{upstream}

# what would be pushed
out = log @{upstream}..HEAD
; out = log @{u}..

# List contributors with number of commits.
contributors = shortlog --summary --numbered

#+end_src

** Grep
#+begin_src gitconfig :prologue "[grep]"
patternType = perl
lineNumber = true
#+end_src

** Blame
#+begin_src gitconfig :prologue "[blame]"
date = human
; date = relative
#+end_src

** Commit
#+begin_src gitconfig :prologue "[commit]"
; gpgsign = true
; 	template = ~/.config/git/COMMIT_TEMPLATE
; template = ~/.config/git/message
; maybe for only < 50 files?
verbose=true
#+end_src

** Diff
#+begin_src gitconfig :prologue "[diff]"
; ediff?
; tool = nvimdiff
tool = nvim_difftool
trustExitCode = true
; colorMoved = default
colorMoved = plain
mnemonicPrefix=true
renames=true
renameLimit = 5394
algorith=histogram
#+end_src

#+begin_src gitconfig
[diff "bin"]
# Use `hexdump` to diff binary files.
textconv = hexdump -v -C
#+end_src

** Delta
#+begin_src gitconfig :prologue "[delta]"
navigate = true  # use n and N to move between diff sections
; line-numbers = true    # Don't do this.. messes up diffs in magit
side-by-side = true
; syntax-theme = tokyonight_moon
; syntax-theme = Dracula
#+end_src

** Difftool
#+begin_src gitconfig :prologue "[difftool]"
prompt=false
#+end_src

*** nvim_difftool
#+begin_src gitconfig :prologue "[difftool \"nvim_difftool\"]"
cmd = nvim -c \"packadd nvim.difftool\" -c \"DiffTool $LOCAL $REMOTE\"
# use it for prs as well: git difftool -d main
#+end_src

** Merge
#+begin_src gitconfig :prologue "[merge]"
tool = nvimdiff2
 conflictstyle = diff3
; zealous
;conflictstyle = zdiff3
; ff = false
# Include summaries of merged commits in newly created merge commit messages
; log = true
#+end_src

** Mergetool
#+begin_src gitconfig :prologue "[mergetool]"
prompt=true
; keepBackup = false
#+end_src

** Fetch
#+begin_src gitconfig :prologue "[pull]"
; prune=true
; pruneTags=true
; all=true
#+end_src

** Pull
#+begin_src gitconfig :prologue "[pull]"
; ff = only
; rebase=true
#+end_src

** Push
#+begin_src gitconfig :prologue "[push]"
default=simple
; autoSetupRemote=true
; followTags=true
#+end_src

** Branch
#+begin_src gitconfig :prologue "[branch]"
sort = committerdate
; sort = -committerdate
#+end_src

** Rerere
#+begin_src gitconfig :prologue "[rerere]"
enabled=true
autoupdate=true
#+end_src

** Tag
#+begin_src gitconfig :prologue "[tag]"
sort = version:refname
#+end_src

** Column
#+begin_src gitconfig :prologue "[column]"
ui=auto
#+end_src

** Color
#+begin_src gitconfig :prologue "[color]"
ui = true

[color "branch"]
    current = yellow reverse
    local = yellow
    remote = green

[color "diff"]
    meta = yellow bold
    frag = magenta bold
    old = red bold
    new = green bold

[color "status"]
    added = yellow
    changed = green
    untracked = red
#+end_src

** Url
#+begin_src gitconfig
; [url "git@github.com:"]
; insteadOf = https://github.com/

[url "https://github.com/"]
    insteadOf = gh:

[url "https://gist.github.com/"]
    insteadOf = gist:

[url "https://bitbucket.org/"]
    insteadOf = bb:
#+end_src

** LFS
#+begin_src gitconfig
; [filter "lfs"]
; clean = git-lfs clean -- %f
; smudge = git-lfs smudge -- %f
; process = git-lfs filter-process
; required = true
#+end_src

** Advice
#+begin_src gitconfig :prologue "[advice]"
; detached = head
#+end_src

** Help
#+begin_src gitconfig :prologue "[help]"
autoCorrect=prompt
#+end_src

** GC
Never garbage collect commits/blobs that are unreachable
The cost of keeping this data around is negligble compared losing data

#+begin_src gitconfig :prologue "[gc]"
reflogExpire = never
reflogExpireUnreachable = never
#+end_src

** Credential
#+begin_src gitconfig :prologue "[credential]"
helper = cache
credentialStore = gpg
#+end_src

** Interactive
delta github
#+begin_src gitconfig :prologue "[interactive]"
diffFilter = delta --color-only
#+end_src

** Rebase
#+begin_src gitconfig :prologue "[rebase]"
; autoSquash=true
; autoStash=true
; updateRefs=true
#+end_src

** Safe
#+begin_src gitconfig :prologue "[safe]"
; directory=
#+end_src

** IncludeIf
Is it possible to tangle at end of file with directive?
#+begin_src gitconfig
; [includeIf "gitdir:~/work"]
; path = ~/.config/git/work
#+end_src

* Commit template
:PROPERTIES:
:header-args: :tangle ~/.config/git/message
:END:

# :header-args: :tangle ~/.config/git/COMMIT_TEMPLATE

#+begin_src text
# Title: Summary, imperative, start upper case, don't end with a period
# No more than 50 chars. #### 50 chars is here:  #

# Remember blank line between title and body.

# Body: Explain *what* and *why* (not *how*). Include task ID (Jira issue).
# Wrap at 72 chars. ################################## which is here:  #

# At the end: Include Co-authored-by for all contributors. 
# Include at least one empty line before it. Format: 
# Co-authored-by: name <user@users.noreply.github.com>
#
# How to Write a Git Commit Message:
# https://chris.beams.io/posts/git-commit/
#
# 1. Separate subject from body with a blank line
# 2. Limit the subject line to 50 characters
# 3. Capitalize the subject line
# 4. Do not end the subject line with a period
# 5. Use the imperative mood in the subject line
# 6. Wrap the body at 72 characters
# 7. Use the body to explain what and why vs. how
#+end_src

* Gitignore
:PROPERTIES:
:header-args: :tangle ~/.config/git/ignore
:END:

#+begin_src gitconfig
# vim: ft=gitignore:
# magari rimuovi _global dal filename?

# Direnv files
.direnv
.envrc

# Editor specific files and folders
.idea
.vscode
# nvim.lua?
*.swp
*.swo
#+end_src
