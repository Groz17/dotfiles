#+property: header-args :tangle ~/.bashrc
#+startup: content

* TODO TASK LIST

#+begin_src bash
# If not running interactively, don't do anything
[[ $- != *i* ]] && return
#+end_src

* Options
#+begin_src bash
shopt -s cdspell
# shopt -s checkwinsize
#+end_src

* Keymaps
#+begin_src bash
bind -x '"\ew": printf %s "$READLINE_LINE" | wl-copy'
bind -x '"\C-xp": "printf %s \"${PWD/#$HOME/\~}\" | wl-copy"'
# ^ like in Vim
bind -x '"\C-x^": exec zsh'
#+end_src

** TODO Toggle shopts
https://github.com/ghostty-org/ghostty/discussions/5851
Use f13 like for neovim/emacs toggling keymaps
#+begin_src bash
# Toggle extglob (enable extended pattern matching)
# bind '"\C-xe": "\C-u shopt -q extglob && shopt -u extglob || shopt -s extglob\n"'
# bind -x '"\C-x/": "shopt -q extglob && shopt -u extglob || shopt -s extglob"'
# bind -x '"\C-x*": "shopt -q globstar && shopt -u globstar || shopt -s globstar"'
# stty wrap?
#+end_src

* Aliases
#+begin_src bash :noweb yes
<<sh|.org:aliases()>>

# Enable tab completion for function wrappers using complete-alias
# https://github.com/cykerway/complete-alias
if [ -f /usr/share/bash-complete-alias/complete_alias ]; then
    source /usr/share/bash-complete-alias/complete_alias
    <<sh|.org:completion-functions()>>
    for entry in "${_completion_funcs[@]}"; do
        IFS=: read -r alias_name cmd_name <<< "$entry"
        complete -F _complete_alias "$alias_name"
    done
    unset _completion_funcs
fi
#+end_src

* Functions
#+begin_src bash :var distro=(org-sbe "distro")
function WTF {
case "$distro" in
  arch) acronyms_location=/usr/share/wtf/acronyms.comp;;
  fedora) acronyms_location=/usr/share/misc/acronyms.comp;;
esac

wtf  $(< "$acronyms_location" cut -f1 | shuf -n1)
}


# PROMPT_COMMAND='printf "\033]133;A\007"'


# man() {
#     emacsclient -t -e "(man \"$*\")"
# }



html2pdf() {
	typst compile <(rdrview -H "$1" | pandoc -f html -t typst) /dev/stdout | zathura -
}

# try the same w/ elisp/clojure
# ascii_quiz
aq() {
for (( ; ; )); do
	# line="$(nvim -es -V1 <<<'for i in range(0,127) | echo i.."\t"..strtrans(nr2char(i)) | endfor' |& grep -P ^\\d | shuf -n1)" &&
	line="$(nvim -es -V1 <<<'for i in range(0,127) | echo i.."\t"..keytrans(nr2char(i)) | endfor' |& grep -P ^\\d | shuf -n1)" &&
        awk '{print $2}' <<<"$line" && read -p $'\e[1mEnter code: > \e[0m' guessed_code 

	correct_code="$(awk '{print $1}' <<<"$line")"
	[ $correct_code == $guessed_code ] && echo "Correct" || echo "Wrong! ($correct_code)"
done
}

adbvw() {

adb get-state 2>/dev/null | grep -q "device" || { notify-send "Not connected"; return 1; }

files=$(adb shell find /sdcard/Documents/Obsidian_vault/Data -maxdepth 1 -name '*.md')
[[ -z "$files" ]] && return 1;
dir=~/vimwiki/Obsidian_vault/phone
[ -d "$dir" ] && cd "$dir" || { notify-send "Directory doesn't exist"; return 1; }
for f in $files; do [[ -f "${f##*/}" ]] && adb pull "$f" "${f##*/}"_$(date +%s) || adb pull "$f" .;done
# attenzione agli spazi
adb shell rm $files
}


#+end_src


** Functions
#+begin_src bash :noweb yes
<<sh|.org:functions()>>
#+end_src

* External commands
#+begin_src zsh :noweb yes
<<sh|.org:commands(shell="bash")>>
#+end_src
