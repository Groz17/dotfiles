#+property: header-args :tangle ~/.config/kanata/config.kbd :comments org
#+startup: content
;; two/multiple keys to activate layer?
;; config.kbd beautifier?

;; use touchpad for \ (in the middle)?
;; would be cool to try using space/touchpad to mean <c-o> (for vim insert mode)
;;write diff between pc and laptop?
;; check if tangled code is valid kanata when saving?


* TODO TASK LIST
org-babel for kanata/config files in general?

basically i want: 
- [ ] press fast and release: that letter
- [ ] press and hold: another behaviour
- [ ] press and hold release before X time: shifted version
- [ ] press and hold release after X time: behaviour (for which-key)
- [ ] use touchpad for localleader?

- [ ] cancel control if C-c C key follows a [^[:alpha:]]
- [ ] if u manage to make shift+1,2,3,4 useless, make sure to bind that to f keys for emacs (macros)
- [ ] key that repeats two times the shifted version of char, for stuff like &&, etc...
- [ ] hold keys for stuff like \ and C-z for emacs (from insert mode normal command?)
- [ ] rpt-key should take 1-8 as argument for last 1-8 keys? also range
- [ ] fai che 2 pressi funga lo stesso , tipo c-xc-s c-xc-c
- [ ] makes it so trackpoint creates a layer and g (or maybe space)-> left click, h-> right, b-> middle
- [ ] maybe also prefix for lsp, etc...?
- [ ] also touchpad for C-u?
- [ ] use super + q for macros (bind to f23 and wtype in hyprland?)
- [ ] disaccoppia ctrl+<symbol> to ctrl+<symbol> when held, like ctrl-h in emacs (works for prefix keymaps)
- [ ] create function layer?
- [ ] usa mdSlash/hyprkan
- [ ] disable for stuff like games? emacs tetris i need repeat
- [ ] caps/a & l/; for [,]
- [ ] create layer for left hand with hjkl being respectively gfds
- [ ] layer for accents? altgr? or maybe just substitute with abbrev e' for example to é
- [ ] ridonandanza nei layer? tipo per c-x in emacs
- [ ] 2/3 & 9/0 easy to reach
- [ ] cant seem to use <c-cr>...
- [ ] maybe use abbreviations like the for awkward keys?
- [ ] variation of same keybinding to stay on that layer? so u can release the key
- [ ] fai che df<symbol>=ctrl-alt-<symbol>, fd e rilascia->esc, fd e <symbol>->ctrl-alt-symbol layer
- [ ] make a touchpad press be rpt-any? also explore zones... (maybe also for symbols, like %(left top)&^(right top), rpt-any (top center))

crea tutti o i piu importanti prefix in emacs like (place keys considering importance and mnemonics, like /&? for M-s)
- [X] C-h
- [X] C-x
- [ ] C-c (also stuff like C-c C-x)
- [X] M-s
- [ ] M-g
  also for every two keypress prefix use a letter, like q (macro key in vim) for C-x C-k (macro key in emacs), etc...

* SETTINGS
#+begin_src kbd

(defcfg
;;obiettivo finale
  ;; Block keys outside the ideal keyboard size/limit, build muscle memory
  ;; block-unmapped-keys yes
  process-unmapped-keys yes
  ;;linux-x11-repeat-delay-rate 300,73
  log-layer-changes no
  linux-use-trackpoint-property yes
;; linux-only-linux-dev-names-onClude
  linux-continue-if-no-devs-found yes
  ;; notify-cfg-reload-silent yes
  linux-dev-names-exclude (
    "Keebart sofle_choc_pro"
    ;; "ThinkPad Extra Buttons"
    ;; "TPPS/2 IBM TrackPoint"
  )
  concurrent-tap-hold yes
;;  chords-v2-min-idle 200
)

#+end_src

* KEYBOARD
conditinally tangle:
, #+begin_src python :tangle (when (not (string-match  "Battery status not available" (battery))) "laptop.sh")

make ansi and iso defsrc?

#+begin_src kbd
;; e un bene che bspc sia in una posizione scomodina (non vuoi favoreggiare sbagli)
(defsrc
  esc 
  grv  1    2    3   4    5    6    7 8 9 - = bspc
  tab  q    w    e   r    t    y    u i o p [ ]   
  caps a    s    d   f    g    h    j k l ; ' \    ret
  lsft <    z    x   c    v    b    n m , . / rsft
  lctl lmet lalt spc ralt ssrq rctl
  mlft mmid mrgt
)
  ;;lalt           spc            ralt menu
;; maybe lftl ctrl and mrgt shift and mmid alt? layers ofc

(deflayer base
  @esc 
  @grv  @d1   @d2   @d3  @d4   @d5   @d6   @d7 @d8 @d9 @- @= @bspc
  @tab  @q    @w    @e   @r    @t    @y    @u  @i  @o  @p @[ @]   
  @caps @a    @s    @d   @f    @g    @h    @j  @k  @l  @; @' @\    @ret
  @lsft @ISO  @z    @x   @c    @v    @b    @n  @m  @,  @. @/ @rpar
  @lctl @lmet @lalt @spc @ralt @menu @rctl
  @mlft @mmid @mrgt
)
#+end_src

* VARIABLES
#+begin_src kbd
(defvar
  tt 300
  ht 330
)

 ;;(defvirtualkeys fk1  (layer-switch nav))
#+end_src

* ALIAS

z=f13, x=f14, c=f15, ...
you could inoremap/abbrev them tbh

#+begin_src kbd

(defalias

;; []-> -+/_*
  ;; [   (tap-hold 200 249 (macro S-5) (macro S-bspc)) ;; same place as [{
  [   (tap-hold 200 249 [ [) ;; same place as [{
  ;; [   (tap-hold 200 249 - (macro S--) ;; same place as [{
  ;; ]   (tap-hold 200 249 (macro S-1) (macro S-bspc)) ;; comfortable to type %!
  ]   (tap-hold 200 249 ] (macro S-8))
  \   (tap-hold 175 175 \ (macro S-\))
  ;; f11 lrld
  ;;  f11 f11
  ;;f11 (layer-switch nav)

  ;; tab   (tap-hold 0 175 tab (macro S-tab))
  ;; alla fine tab naviga nei form...
 ;; tab (tap-hold 175 100 tab (tap-hold-release-timeout 0 200 tab (layer-while-held nav) (macro S-tab)))
 tab (tap-hold 175 100 tab (tap-hold-release-timeout 0 200 tab (layer-while-held nav) (macro S-tab)))
  home   home
  ;;[   (tap-hold 200 249 [ (layer-switch nav))
  ;; non funge
  ;;[   (tap-hold 200 249 (layer-switch nav) (layer-switch base))
  ;;]   (tap-hold 200 249 ] (layer-switch base))
  ;; in futuro [ (layer-switch nav)
  ;; how to tap caps to go to layer starting only if in another layer?
  ;;tab (on-press toggle-virtualkey fk1)
  ;; menu (layer-switch nav)
  ;; opposite of | for shell scripting
  menu (macro S-7)
  ret (tap-hold 200 249 ret (macro S-ret))
  ;; can rpt-any work with chords as well? if not make it work
  ;; combine rpt-any w/ tap-hold? like for neovim debug
  ;; make rpt-any work w/ chords?
  ;;vin   (tap-hold 200 249 rpt-any (layer-while-held nav))
  ;; vin   (tap-hold 200 249 rpt-any (layer-while-held nav))
  ;; vin (tap-dance 300 (tap-hold-press-timeout 200 200 rpt-any [ (macro S-[)) [ )
;; make rpt-any work w/ esc/cr (fd/jk)
  ;; caps (tap-dance 300 (rpt-any (caps-word 10000) ))
  ;; caps (tap-hold 175 200 (tap-dance 300 (rpt-any (caps-word 10000) )) (tap-hold-press-timeout 0 100 [ lctl (macro S-[)))
  ;; also continue if pressing c-h, c-w, etc...
  ;; caps-word with number before (like v:count) to mean make these next n letters uppercase
  ;;caps (tap-hold 175 200  rpt-any (tap-hold-press-timeout 0 100 rpt-any (layer-while-held nav) (caps-word 10000)))
  ;;caps (tap-hold 175 200  rpt-any (tap-hold-press-timeout 0 100 rpt-any (layer-while-held nav) (caps-word 10000)))
  ;; basically at the opposite end of '/"
  ;;caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave lsft (macro S-grave)))
  ;;caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave (layer-while-held num) (macro S-grave)))
  ;;basically\ because evil, universal argument
  ;; maybe this way u can use c-u in insert mode (replicate readline in emacs)
  ;;caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave (macro \ C-u) (macro S-grave)))
  caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave (layer-while-held nav) (macro S-grave)))
  ;;< (tap-hold-press-timeout 200 175 S-\ lsft (macro S-[))
;;  < (macro S-6) ;; ^ looks like shift symbol
;; useful for (emacs lisp)
  lsft (tap-hold-press-timeout 200 175 (macro S-6) (macro S-9) (macro S-[))
  ;;vin   (tap-hold 200 249 bspc (layer-while-held nav))

  rpar (tap-hold-press-timeout 200 175 S-0 rsft (macro S-]))
  ;; capsline?
  cwr (caps-word-toggle 10000)
  ;; lalt (tap-hold 200 200 mmid lalt)
  ;; lalt mlft
  ;;lalt (tap-hold-press-timeout 200 200 mlft lalt bspc)
  ;; lalt (tap-hold-press-timeout 200 200 - lalt mlft)
  ;; comfortable (u also use left thumb for space)
  ;; do em dash/ dash / en? others? also underscore?
  ;;lalt (tap-hold 200 200 - (unicode —))
  ;;lalt ((tap-hold-press-timeout 200 175 - (layer-while-held symbols) (unicode —)))
  ;;combina bene con caps-word...
  ;; lalt (tap-hold 200 175 - (macro S--))
  ;; to easily press -> or smth...
  ;; maybe _ when holding so same speed as for -?
  ;;lalt (tap-hold-press-timeout 200 175 - (multi - lsft) (macro S--))
  ;;lalt (tap-hold-press-timeout 200 175 - (macro S-\)  (macro S--))
  ;; doesn't work with \| tough
  ;; i guess also useful for evil in emacs, like for calc
  ;; lalt (tap-hold 175 175 - (tap-hold-press-timeout 0 100 - (multi \) (macro S--)))
  lalt (tap-hold 175 175 - (tap-hold-press-timeout 0 230 - (layer-while-held audio) (macro S--)))

  ;; combina bene con - per pipelines
  ;;ralt (macro S-\)

  ;; basically better position for - and = (this make them work with shift layer)
  ;;ralt (tap-hold 200 175 = (macro S-=))
  ;; per shell pipeline: mnemonic: eventuali opzioni vengono prima della pipe
  ;; also nice for org mode tables |-tab goes all in one direction
  ;;ralt (tap-hold 175 150 (multi lsft \) (tap-hold-press-timeout 0 100 (multi lsft \) \ (macro S-d)))
  ralt (tap-hold 175 175 = (tap-hold-press-timeout 0 100 = \ (macro S-=)))

  ;;lctl (macro S-3)
   ;; lctl \
   lctl rpt-any ;; ... doesn't work with c-m-s-v though? for emacs
  ;;lctl (macro S-1) ;; near | and vertical aligned with 1/!
  rctl (macro S-8)
  ;;rctl (macro S-\)
  ;; facile usare |-tab in orgmode (also nice for pipelines near -)
  ;; lmet \
  ;; so i can easily do |- in org mode for tables ; also near - for bash commands
  lmet (macro S-\)

#+end_src

** MOUSE
#+begin_src kbd :tangle (if (string-match  "Power N/A, battery unknown (N/A% load, remaining time N/A)"(battery)) "no" (cdr (assq :tangle (org-babel-parse-header-arguments (cdr (assoc "header-args" org-keyword-properties))))))
;; how to make touchpad work?

;; maybe define these just for neovim since u aint gonna use the mouse (define env var in neovim like IS_NEO?)
;; also use trackpoint tap for left click and hold for right click
;; mi forza a non usare il mouse
;; why doesn't the touchpad work?
;; TODO: add held action for these (like push to talk and ???)
;;mlft (tap-hold 175 100 [ (tap-hold-release-timeout 0 200 [ (layer-while-held symbols) (layer-while-held symbols)))
;; mlft (tap-hold 175 100 [ (tap-hold-release-timeout 0 100 [ (layer-while-held num) mlft))
mlft (tap-hold 175 100 [ (tap-hold-release-timeout 0 100 [ [ mlft))
;;tap:- hold:_ double-tap:= (it all makes sense)
;; mlft (tap-dance 230 ( (tap-hold-press-timeout 200 175 - - S-- ) =))
 ;; mlft (tap-hold 175 100 bspc (tap-hold-release-timeout 0 200 [ (layer-while-held symbols) mlft))
;; mlft mlft
;;mlft (tap-hold 175 150 - (tap-hold-release-timeout 0 100 - [ -))
;; rpt-any kinda allows to cheat key-repeat... (press one and the other in rapid succession) (the key or the other rpt-any key)
;; maybe make it so key-repeat works?
;;mlft (tap-hold 175 150 rpt-any (tap-hold-release-timeout 0 100 rpt-any (layer-while-held symbols) -))

;; use \ as mmid (like ascii sequence, also nice for localleader?)
;; maybe keep as mmid? and trackpoint as mlft&mrgt
;;mmid (tap-hold 175 100 \ (tap-hold-release-timeout 0 100 \ (layer-while-held num) (macro S-\)))
;;mmid (tap-hold 175 100 S-- (tap-hold-release-timeout 0 100 S-- (layer-while-held num) (macro S-\)))
;;mmid S--
mmid mmid

;; non usare mrgt come symbols layer xke i simboli sono gia alla destra in qwerty
 ;;mrgt (tap-hold 175 100 ] (tap-hold-release-timeout 0 200 ] (layer-while-held num) (layer-while-held num)))
 mrgt (tap-hold 175 100 ] (tap-hold-release-timeout 0 200 ] ] mrgt))
;; basically right thumb backspace ] as layer held s-bspc, left thumb [ and held ] and [ as layer
;; mrgt (tap-hold 175 100 bspc (tap-hold-release-timeout 0 200 bspc ] mrgt))
;;mrgt (tap-hold 175 100 ] (tap-hold-release-timeout 0 100 ] (layer-while-held num) (macro S--)))
;;mrgt (tap-hold 175 150 (macro S--) (tap-hold-release-timeout 0 100 (macro S--) ] (macro S--)))
;;mrgt (tap-hold 175 150 rpt-any (tap-hold-release-timeout 0 100 rpt-any (layer-while-held symbols) (macro S--)))

;; hai a disposizione 4 caratteri: lsft and 3 mouse buttons.
;; does tap-dance work with rpt-any? no, sfrutta a tuo vantaggio...
;; use leader and localleader with mouse buttons to get more symbols; also use chords with them? like modifier+leader, since a leader assumes
;; something after this is great...
;; mrgt (tap-dance 300 ( (macro S--) = ))

#+end_src

#+begin_src kbd :tangle (if (string-match  "Power N/A, battery unknown (N/A% load, remaining time N/A)"(battery)) (cdr (assq :tangle (org-babel-parse-header-arguments (cdr (assoc "header-args" org-keyword-properties))))) "no")
mmid mmid
mrgt mrgt
mlft mlft
#+end_src

** Macros
EXWM would be perfect for these ig
v:count?
also S-9 and S-0 could be an idea (like emacs c-x())
better to toggle though
sleep-for?
super+q?
useful for repetitive password insertions 😁 (ssh)
show macro content

#+begin_src kbd
;; - (tap-hold-press-timeout 175 175 rpt-any - (macro S--))
;; in tridactyl: bind f12( -?
- (tap-hold-press-timeout 175 175 (dynamic-macro-record 0) - (macro S--))
= (tap-hold-press-timeout 175 175 dynamic-macro-record-stop = (macro S-=))
;;grv (tap-hold 200 249 grv (macro S-grv)) ;; usa C-u 0 for emacs (comes before vim)
;; remember u can also use keys like FAVORITES (from mapping.txt)
;; grv (tap-hold 200 249 f14 (macro S-grv)) ;; usa C-u 0 for emacs (comes before vim)
grv (tap-hold 200 249 (dynamic-macro-play 0) (macro S-grv)) ;; usa C-u 0 for emacs

;; double shift/caps tab?
;; map it to disable/toggle kanata (for when you pass pc to other)
;; esc caps
;; esc (tap-hold 200 249 (dynamic-macro-play 0) (macro S-grv)) ;; usa C-u 0 for emacs
;; how to repeat?
;; esc (tap-hold 200 249 (dynamic-macro-play 0) (dynamic-macro-play 0)) ;; usa C-u 0 for emacs
esc (dynamic-macro-play 0)
#+end_src

** HRM
Keys used: d, f (& mirrored) and space (no need for shift because of autoshift)
Order tap-hold section based on keyboard location (space, zxcv, asdfg, qwert)
Keep in mind there's also shift, caps, tab, ISO key, etc...
There's also modifier+function keys btw

*** Super
#+begin_src kbd
spc (tap-hold-press-timeout 0 200 spc lmet (multi S-spc))
#+end_src

*** Ctrl
#+begin_src kbd
;; make lctl sticky (for ctrl-h backspace), like ctrl-h and then press again should repeat?
;; if d and m pressed at the same time-> double ctrl, for things like c-cr (c-c-m)
d (tap-hold 175 175 d (tap-hold-press-timeout 0 230 d lctl (macro S-d)))

k (tap-hold 175 175 k (tap-hold-press-timeout 0 230 k rctl (macro S-k)))
#+end_src

*** Alt
#+begin_src kbd
;; change this out for the list:https://github.com/jtroo/kanata/blob/main/cfg_samples/home-row-mod-advanced.kbd
f (tap-hold 175 175 f (tap-hold-press-timeout 0 230 f lalt (macro S-f)))
;; usa release e press solo x escape...

;; j (tap-hold 150 150 j (tap-hold-press-timeout 0 200 j (layer-while-held syms_for_j) (macro S-j)))
j (tap-hold 175 175 j (tap-hold-press-timeout 0 230 j lalt (macro S-j)))

#+end_src

** Toggle
#+begin_src kbd
;; z inspiration from c-z toggle evil in emacs...
;; make this sticky
;; basically Toggle cause C-z toggle evil mode in emacs
z (tap-hold 150 175 z (tap-hold-press-timeout 0 75 z f13 (macro S-z)))
. (tap-hold 150 175 . (tap-hold-press-timeout 0 75 . f13 (macro S-.)))
#+end_src

** TODO
#+begin_src kbd
;; v (tap-hold 150 200 v (tap-hold-press-timeout 0 150 v i (macro S-v)))
;; n (tap-hold 150 200 n (tap-hold-press-timeout 0 150 n i (macro S-n)))
v (tap-hold-press-timeout 175 175 v v (macro S-v))
n (tap-hold-press-timeout 175 175 n n (macro S-n))
#+end_src

** Terminal
#+begin_src kbd
;; use e/i 'cause middle finger is the strongest ig
;; crea modifiers nuovi with super + combinazione di altri modifiers: super+{cltrl,alt,shift} 2^3 insieme delle parti (except shift only for hyprland)
;; can also do super+modifiers+symbols (for neovim/emacs/editor leader...)
;; e (tap-hold 175 150 e (tap-hold-press-timeout 0 100 e (multi lmet lalt) (macro S-e)))
;;lmet lctl so i can press lmet+lctl+lalt easily w/ w+d
e (tap-hold 175 175 e (tap-hold-press-timeout 0 100 e (multi lmet lalt) (macro S-e)))

i (tap-hold 175 175 i (tap-hold-press-timeout 0 150 i (multi lmet lalt) (macro S-i)))
#+end_src

** One-shot/localleader (C-c ...)
#+begin_src kbd
;; u could maybe use this for hyper/super in emacs since u run it as a GUI
;;c (tap-hold 175 200 c (tap-hold-press-timeout 0 200 c (multi lmet lalt) (macro S-c)))
;; nice position so u can use ctrl-x arrow in emacs

;; for C-u use macros , v:count like for C-u,C-u,C-u

c (tap-hold 175 200 c (tap-hold-press-timeout 0 200 c f15 (macro S-c)))
m (tap-hold 175 200 m (tap-hold-press-timeout 0 200 m f15 (macro S-m)))
#+end_src

** Window mappings

#+begin_src kbd
;; magari crea f16 when it does this char= getchar; exe <cmd>char..<cr> (basically one letter commands) and maybe double quotes two letters?
;; so i can preserve C-\ input in emacs
a (tap-hold 175 175 a (tap-hold-press-timeout 0 175 a f16 (macro S-a)))
; (tap-hold 0 150 ; (tap-hold-press-timeout 0 100 ; f16 (macro S-;)))
#+end_src

#+begin_src kbd

;; ───────────────────────────── register ──────────────────────────────
;; one-shot modifier for ctrl-u universal arg?
;;per vim
r (tap-hold 175 175 r (tap-hold-press-timeout 0 100 r (macro C-r) (macro S-r)))
;; work on autorepeat? like if over>250 UU?
;;u (tap-hold 175 150 u (tap-hold-press-timeout 0 100 u (macro C-r) (macro S-u)))
;; for emacs (4 is the default)
;;maybe C-u for emacs? when held?
u (tap-hold 175 175 u (tap-hold-press-timeout 0 100 u (macro C-u) (macro S-u)))
;;u (tap-hold 175 150 u (tap-hold-press-timeout 0 100 u (multi lctl u) (macro S-u)))
#+end_src

** C-x emacs
C-x is also useful for readline

#+begin_src kbd
;; s (tap-hold 150 175 s (tap-hold-press-timeout 0 75 s f13 (macro S-s)))
;;s (tap-hold-release 150 175 s (tap-hold-press-timeout 0 75 s (macro C-x) (macro S-s)))
;; how to activate C-x when pressed and not released?
;;s (tap-hold 150 175 s (tap-hold-press-timeout 0 230 s (macro C-x) (macro S-s)))
;;s (tap-hold 150 175 s (tap-hold-press-timeout 0 230 s f15 (macro S-s)))
;; f15 not recognized in terminal (for readline c-x c-e) (.inpurc line)
;; make it press f12 unless released so which-key buffer pops up...
;; make it hyper so u can hold s, sd, etc...
s (tap-hold 150 175 s (tap-hold-press-timeout 0 230 s f12 (macro S-s)))

;; l (tap-hold 150 175 l (tap-hold-press-timeout 0 75 l f13 (macro S-l)))
;; l (tap-hold 150 175 l (tap-hold-press-timeout 0 75 l f15 (macro S-l)))
l (tap-hold 150 175 l (tap-hold-press-timeout 0 150 l f12 (macro S-l)))
#+end_src

#+begin_src elisp

  ;; basically d and f are ctrl and alt, and x is c, c is ctrl alt (fusion of d and f) and v is alt
  ;;x (tap-hold-press-timeout 175 175 x (multi lctl u lctl) (macro S-x))
  ;;x (tap-hold-press-timeout 175 175 x (multi lctl c lctl x lctl) (macro S-x))
  ;; basically x is for snacks keymaps (ks mnemonic)
  ;; maybe map to c-c c-x? it's in the middle of c-x and c-c
  ;;x (tap-hold-press-timeout 175 175 x f14 (macro S-x))
  x (tap-hold 150 175 x (tap-hold-press-timeout 0 124 x x (macro S-x)))
  ;;, (tap-hold-press-timeout 190 157 , (multi lctl c lctl x) (macro S-,))
  ;; , (tap-hold-press-timeout 190 157 , f14 (macro S-,))
  , (tap-hold-press-timeout 190 157 , , (macro S-,))
#+end_src

** Help
#+begin_src kbd
;; for emacs

;; fai che quando g e premuto, h diventa ctrl e viceversa (for emacs help mappings)
g (tap-hold 150 200 g (tap-hold-press-timeout 0 150 g f18 (macro S-g)))
h (tap-hold 150 200 h (tap-hold-press-timeout 0 150 h f18 (macro S-h)))
#+end_src

** Picker (window mnemonic)
Those should be temporary mappings until editor's default mappings are added

#+begin_src kbd
;; use modifier instead so u can use ^w{h,j,k,l} in terminal & in insert mode
w (tap-hold 175 200 w (tap-hold-press-timeout 0 100 w f17 (macro S-w)))
o (tap-hold 175 200 o (tap-hold-press-timeout 0 100 o f17 (macro S-o)))
#+end_src

** Translation
#+begin_src kbd
t (tap-hold 150 200 t (tap-hold-press-timeout 0 150 t f14 (macro S-t)))
y (tap-hold 150 200 y (tap-hold-press-timeout 0 150 y f14 (macro S-y)))
#+end_src

#+begin_src kbd
p (tap-hold-press-timeout 175 175 p p (macro S-p))
q (tap-hold-press-timeout 175 175 q q (macro S-q))

;;n (tap-hold 150 175 n (tap-hold-press-timeout 0 124 n (macro C-c C-v) (macro S-n)))
b (tap-hold-press-timeout 175 175 b b (macro S-b))
;;n (tap-hold-press-timeout 175 175 n n (macro S-n))
#+end_src

#+begin_src kbd

' (tap-hold-press-timeout 200 157 ' ' (macro S-'))
` (tap-hold-press-timeout 200 157 ` ` (macro S-`))

;; for searching... mnemonic: / in Vim
ISO (tap-hold-press-timeout 200 175 S-9 (macro A-s) (macro S-[))

;; / simmetrico di (
;;/ (tap-hold-press-timeout 200 157 / ] (macro S-/))
;; tanto usi rpt-any, giusto? 
;; maybe C-s when held for emacs?
;;/ (tap-hold-press-timeout 200 157 / rsft (macro S-/))
;;/ (tap-hold-press-timeout 200 157 / (multi lalt s) (macro S-/))
/ (tap-hold-press-timeout 200 157 / (macro A-s) (macro S-/))

bspc (tap-hold-press-timeout 175 175 bspc bspc (macro S-bspc))

;; tasti liberiii (maybe use (held) super for hyprland/wm, like associate with workspace name)
;; do maybe maths
;; maybe function keys when held? but what about shifted fun keys?
d1 (tap-hold-press-timeout 175 175 1 1 (macro S-1))
d2 (tap-hold-press-timeout 175 175 2 2 (macro S-2))
d3 (tap-hold-press-timeout 175 175 3 3 (macro S-3))
d4 (tap-hold-press-timeout 175 175 4 4 (macro S-4))
d5 (tap-hold-press-timeout 175 175 5 5 (macro S-5))
d6 (tap-hold-press-timeout 175 175 6 6 (macro S-6))
d7 (tap-hold-press-timeout 175 175 7 7 (macro S-7))
d8 (tap-hold-press-timeout 175 175 8 8 (macro S-8))
;; change hold for 9 and 0 (i use shift for those)
d9 (tap-hold-press-timeout 175 175 9 9 (macro S-5))
;;d0 (tap-hold-press-timeout 175 175 0 0 (macro S-6))
;;d0 (tap-hold-press-timeout 175 175 0 0 f13)
;; doesn't work?
d0 (tap-hold-press-timeout 175 175 0 0 0)
)
#+end_src

* LAYERS
how to use autoshift w/ a layer? like G to go to end
implement vim layer? like gg and stuff
notify when layer switching?
magari usalo anche x emacs (fallo simmetrico)
also use shift-arrow for orgs emacs

** Navigation
Also toggle layer activation?

#+begin_src kbd
(deflayer nav
_
_ _ _ _     _ _ _ _    _    _  _    _ _
_ _ _ _     _ _ _ _    _    _  _    _
_ _ _ _     _ _ _ left down up rght _ _ _ _
_ _ _ _     _ _ _ _    ret  _  _    _ _
_ _ _ _     _ _ _
_ _ _
)

;; (deflayer nav_sx
;; _
;; _ _ _ _ _ _ _ _ _ _ _ _ _
;;      _    _    _    _    _    _   _    _    _    _    _
;;   _    _    _    rght    up    down    lft    _ _ _ _    _  _  _ _
;;   _   _ _    _    _    _    _    _    _    _    _    _    _
;; _ _ _  _              _              _   _
;;    _ _ _ 
;; )
#+end_src

** TODO Audio
MediaMute: i (i looks like a mic)
Add missing keys w/ playerctl/mpv ipc... (stop, etc...)
#+begin_src kbd
(deflayer audio
  _
  _ _ _              _              _ _   _ _   _          _        _                  _ _
  _ _ _              _              _ _   _ _   f19          f24      MediaTrackPrevious _
  _ _ _              f20            _ f21 _ f22 VolumeDown VolumeUp f23                _ _ _ _
  _ _ _              _              _ _   _ MediaTrackNext   VolumeMute _        _                  _ _
  _ _ _ MediaPlayPause _ _   _
  _ _ _             
)
#+end_src

* CHORDS
 purtroppo Chords legati a layout... qwerty (eventualmente adatta in base a prima letter premuta)
also use alt and altgr... (by themselves+chords)
 find unusual combinations lik hj/jh/etc... (also three (maybe more) letters like kl; ) (the letters don't have to be adiacent)
 double chord taps?
 how to repeat chords w/ rpt-any
#+begin_src kbd

(defchordsv2

;; (j k) (switch ((input-history real k 1)) ret break() (multi lctl alt) break) 130 first-release ()

;;(f d) esc 150 first-release ()
;; use also to toggle another layer
;; (lsft rsft) lrld 250 first-release ()
;; probably better to use lmet mapping?
;; use same mapping as :restart?
;;(f 5) lrld 250 first-release ()
;; how to make it silent in vim?
;; questi accordi non fanno funzionare alt-ctl e potenzialmente shift per una mano
;;(j k l) f12 250 first-release ()
;; (j k) ret 250 first-release ()
;; I keep it just for c-cr and c-a-cr, otherwise use c-m,c-a-m and c-s-m

;; would be nice if it worked with <C-h>
(lsft rsft) (caps-word 10000) 250 first-release ()

;; changing timeout or firstall doesn't seem to change for modifiers... (wanna use djk)
;; (j k) (switch ((input-history real k 1)) ret break() (multi lctl alt) break) 30 first-release ()
;; (j S-k) (switch ((input-history real S-k 1)) S-ret break() (multi lctl alt) break) 150 all-released ()
;; (j S-k) (switch ((input-history real S-k 1)) S-ret break() (multi lctl alt) break) 150 all-released ()
;; (j S-k) (macro S-ret) 250 first-release ()
;; (d f) esc 250 first-release ()
;; maybe dF chord to turn into symbol layer? like dFm to input c-a-%? also what about dFM?
(f d) (switch ((input-history real d 1)) esc break() (multi lctl alt) break) 150 all-released ()
;;(s d f) f12 250 first-release ()
;;non funge
;;(j k l) f13 250 first-release ()
;;(j k l) (macro S-f13) 250 first-release ()
;; flash f13?

;; (c m) (switch ((input-history real c 1)) (macro S-5) break() \ break) 150 all-released ()
;; (z .) (switch ((input-history real z 1)) \ break() grave break) 150 all-released ()
;; (/ .) (switch ((input-history real . 1)) \ break() grave break) 150 all-released ()
;;(/ ( macro  S-9)) (switch ((input-history real / 1)) \ break() grave break) 150 all-released ()
;;(/ ( macro  S-9)) (switch ((input-history real / 1)) S-9 break() S-0 break) 150 all-released ()

;;(mlft mrgt) (switch ((input-history real mlft 1)) = break() (macro S-=) break) 150 all-released ()
;; is it possible to do a tap-hold but for chords? for |...
;;(mlft mrgt) (switch ((input-history real mrgt 1)) \ break() (macro S-\) break) 150 all-released ()
;; (g h) (switch ((input-history real g 1)) (macro S-grave) break() grave break) 150 all-released ()
;; more comfortable
;; (h f) (switch ((input-history real f 1)) (macro S-grave) break() lalt break) 150 all-released ()
;; fj = home (doesn't work with alt...)
;;(f j) (switch ((input-history real j 1)) (macro S-grave) break() grave break) 150 all-released ()
;; (g j) (switch ((input-history real j 1)) grave break() lalt break) 150 all-released ()
;; (g h) (switch ((input-history real h 1)) [ break() ] break) 150 all-released ()
;; (g k) (switch ((input-history real h 1)) [ break() ] break) 150 all-released ()
;; (h d) (switch ((input-history real h 1)) [ break() ] break) 150 all-released ()

;; works for vanilla (neo)vim as well
;; would be nice that you can press kl (emacs mappings c-x c-s), save pressing s and kill pressing ;
;;(mlft mrgt) rpt-any 250 first-release ()
;; one finger only
;; (n m) bspc 250 first-release ()
 ;; TODO: (( /) toggle cpas lock

;; (k l) (tap-hold 200 80 (switch
;;  ((input-history real k 1)) (multi l k) break
;;  ((input-history real l 1)) (multi k l) break
;; ) ret) 50 first-release ())
;; (italian) accents (chords bcs vim digraphs kinda work like that)

#+end_src

** Quick accents
In the future use picker like on phone?
#+begin_src kbd
(a caps)  (unicode à) 100 first-release ()
(a ')  (unicode á) 100 first-release ()

;;(e `)  è 100 first-release ()
;;(e ')  é 100 first-release ()
;;(e `)  (unicode è) 100 first-release ()
;; caps doesn't get translated otherwise (is there a function that translates?)
(e caps)  (unicode è) 100 first-release ()
(e ')  (unicode é) 100 first-release ()

(i caps)  (unicode ì) 100 first-release ()
(i ')  (unicode í) 100 first-release ()

(o caps)  (unicode ò) 100 first-release ()
(o ')  (unicode ó) 100 first-release ()

(u caps)  (unicode ù) 100 first-release ()
(u ')  (unicode ú) 100 first-release ()

)

#+end_src

;; rmet-q(dynamic-macro-record 0)
;; rmet-@(dynamic-macro-play   0)

;; layer to select layers? which-key?

;; writing layer? like for quotes, em dash...

;; mappings to transform last \S+ to pascal, camel (corce-like, same letters)

;; bottom alt tap/hold mapping?

;; one-shot shift? chord?

;;autoshift
;; I use a variable timing depending on the finger. From 100 ms on the index to 135 ms on the pinky. Note that I use low profile choc switches. 
;; activate autoshift only when key is released, so u can use whichkey neovim w/ 13 leader?

;; caps and ; for accents? digraphs?

;; how to make tap-dance work with modifiers?
;;rpt-any should be in either side of the keyboard (maybe altgr/alt?)
;; how to use with multi like ^ww?

;; mappa in modo da rendere piu facili combinazioni usate tipo ctrl-- and ctrl-+ per zoomare?

;; magari, asdfc -> leader, ctrl, alt, symbols, localleader (oppure switcha c-x and c-c in emacs cosi diventa alt,ctrl... pessima idea?)
;; also sdc are easier to type together
;; mappa ctrl-o per normal mode comments in neovim?
;; make ctrl-letter generalized: when not release act as ctrl (do these for All letters and maybe overwrite for HRM?)

;; press symbol that toggle the functionality of a key? like for mouse/square brackets

;; crea prefix for popup completion?

;; use altgr hold for accents/fancy symbols like em dash?

;; maybe use prefix for operators? like g or d hold?

;; mouse layer: trackpoint held and j left k right m middle
